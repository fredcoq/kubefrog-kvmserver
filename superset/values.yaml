#
# Licensed to the Apache Software Foundation (ASF) under one or more
# contributor license agreements.  See the NOTICE file distributed with
# this work for additional information regarding copyright ownership.
# The ASF licenses this file to You under the Apache License, Version 2.0
# (the "License"); you may not use this file except in compliance with
# the License.  You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

# Default values for superset.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.
# nameOverride: superset
fullnameOverride: superset
additionalRequirements:
  - pyhive
  - sqlalchemy-redshift
  - mysqlclient
  - psycopg2
  - redis
  - elasticsearch-dbapi
  - pymssql
  - gsheetsdb
  # Force verstion to work around https://github.com/betodealmeida/gsheets-db-api/issues/15
  - moz-sql-parser==4.9.21002
  # For OAuth
  - Authlib
  # For webdriver / reports
  - gevent
replicaCount: 1

# User ID directive. This user must have enough permissions to run the bootstrap script
# Runn containers as root is not recommended in production. Change this to another UID - e.g. 1000 to be more secure
runAsUser: 0

# Install additional packages and do any other bootstrap configuration in this script
# For production clusters it's recommended to build own image with this step done in CI
serviceAccount:
  create: false


bootstrapScript: |
  python3 /app/configs/load_certificate.py
  if [ ! -f ~/bootstrap ]; then echo "Running Superset with uid {{ .Values.runAsUser }}" > ~/bootstrap; fi


## The name of the secret which we will use to generate a superset_config.py file
## Note: this secret must have the key superset_config.py in it and can include other files as well
##

configFromSecret: '{{ template "superset.fullname" . }}-config'

## The name of the secret which we will use to populate env vars in deployed pods
## This can be useful for secret keys, etc.
##
envFromSecret: '{{ template "superset.fullname" . }}-env'



## Extra environment variables that will be passed into pods
##
extraSecretEnv:
  MAPBOX_API_KEY: pk.eyJ1Ijoia3ViZWZyb2ciLCJhIjoiY2twMnNncnZ4MXB5eTJ5bWN5Ym5kbjRzZiJ9.aZzU6DVFAEnGjxguKi5tQQ
  CLIENT_ID: superset-2021
  CLIENT_SECRET: 550a6df9-f63c-407a-a8cd-d3c272c20bec
  SERVER_URL: https://auth.kubefrog.fr/auth/realms/kubeflow/.well-known/openid-configuration
  # GOOGLE_KEY: ...
  # GOOGLE_SECRET: ...

extraEnv:
  SUPERSET_FEATURE_DASHBOARD_NATIVE_FILTERS: True
  CSV_TO_HIVE_UPLOAD_S3_BUCKET: "spark-warehouse"
  ENABLE_JAVASCRIPT_CONTROLS: True
  HTML_SANITIZATION: False
  TALISMAN_ENABLED: False
  ENABLE_CORS: True
  AWS_ACCESS_KEY_ID: "minioadmin"
  AWS_SECRET_ACCESS_KEY: "minioadmin" 
  AWS_REGION: "minio"                   
  S3_ENDPOINT: "192.168.1.41:9000"  
  S3_USE_HTTPS: "0"
  S3_VERIFY_SSL: "0"
  
  #WTF_CSRF_EXEMPT_LIST: [‘auth.kubefrog.fr’]
  #WTF_CSRF_ENABLED: "False"
  
## Extra environment variables to pass as secrets
##
extraConfigs:
  load_certificate.py: |
    def load_certificate():
      import certifi

      """Read auth ingress certificates""" 
      with  open('/mnt/config/certs/ca.crt','r') as f:
        ca_certs = f.read()

      """import certificate into certifi cert store"""
      cafile = certifi.where()
      with  open(cafile,'a') as outfile:
        outfile.write(ca_certs)
        
    #load_certificate()
      
  # datasources-init.yaml: |
  #     databases:
  #     - allow_csv_upload: true
  #       allow_ctas: true
  #       allow_cvas: true
  #       database_name: example-db
  #       extra: "{\r\n    \"metadata_params\": {},\r\n    \"engine_params\": {},\r\n    \"\
  #         metadata_cache_timeout\": {},\r\n    \"schemas_allowed_for_csv_upload\": []\r\n\
  #         }"
  #       sqlalchemy_uri: example://example-db.local
  #       tables: []  

extraSecrets: {}
extraVolumes:
 - name: oidc-keycloak-config
   secret:
     secretName: '{{ template "superset.fullname" . }}-oidc-keycloak-config'
 # - name: additionalSecret
 #   secret:
 #     secretName: my-secret
 #     defaultMode: 0600
 #- name: auth-ingressgateway-certs
 #  secret:
 #    secretName: kubeflow-ingressgateway-certs-kubefrog

 
extraVolumeMounts:
 - name: oidc-keycloak-config
   mountPath: /mnt/config
   readOnly: true
 #- name: auth-ingressgateway-certs
 #  mountPath: /mnt/config/certs
 #  readOnly: true

 # - name: additionalSecret:
 #   mountPath: /mnt/secret

# A dictionary of overrides to append at the end of superset_config.py - the name does not matter
# WARNING: the order is not guaranteed
configOverrides: 
  # enable_oauth: |
  #   from flask_appbuilder.security.manager import AUTH_DB
  #   AUTH_TYPE = AUTH_OAUTH

  #   OAUTH_PROVIDERS = [
  #       {
  #           "name": "google",
  #           "icon": "fa-google",
  #           "token_key": "access_token",
  #           "remote_app": {
  #               "client_id": os.environ.get("GOOGLE_KEY"),
  #               "client_secret": os.environ.get("GOOGLE_SECRET"),
  #               "api_base_url": "https://www.googleapis.com/oauth2/v2/",
  #               "client_kwargs": {"scope": "email profile"},
  #               "request_token_url": None,
  #               "access_token_url": "https://accounts.google.com/o/oauth2/token",
  #               "authorize_url": "https://accounts.google.com/o/oauth2/auth",
  #           },
  #       }
  #   ]
    general_override: |
        SECRET_KEY = "vhHOL2FHZ9U+PSuDt571+zJTJh745AerMXqcsLPH5NhF0N+Mpye0u59/"
        CSRF_ENABLED = True
        WTF_CSRF_ENABLED = False
        ENABLE_PROXY_FIX = True
        SESSION_COOKIE_SAMESITE = None
        PUBLIC_ROLE_LIKE_GAMMA = True
        GUEST_ROLE_NAME = "Gamma"
        ENABLE_CORS = False #True
        CORS_OPTIONS = {
        'supports_credentials': True,
        'allow_headers': ['*'],
        'resources':['*'],
        'origins': ['*']
        }
        FEATURE_FLAGS = {
               "DYNAMIC_PLUGINS": True,
               "ENABLE_JAVASCRIPT_CONTROLS": True,
               "EMBEDDED_SUPERSET": True
            }
        FILTER_STATE_CACHE_CONFIG = CACHE_CONFIG
        EXPLORE_FORM_DATA_CACHE_CONFIG = CACHE_CONFIG
        AUTH_ROLE_ADMIN = 'Admin'
        AUTH_ROLE_PUBLIC = 'Public'
    enable_oidc_keycloak: |
        from flask_appbuilder.security.manager import AUTH_OAUTH
        from superset.security import SupersetSecurityManager
        CLIENT_ID = "210d7bb2382549be3fd37c3d8d9b1625"
        CLIENT_SECRET = "24067a2105c6a61040d7abc259a9d53f526887f7b0343ef8724ee61dd730f9fa"
        import logging
        AUTH_PROVIDERS = [
          {   'name':'keycloak',
              'token_key':'access_token', # Name of the token in the response of access_token_url
              'icon':'fa-address-card',   # Icon for the provider
              'remote_app': {
                  'client_id': CLIENT_ID,  # Client Id (Identify Superset application)
                  'client_secret': CLIENT_SECRET, # Secret for this Client Id (Identify Superset application)
                  'client_kwargs': {
                      'scope': 'openid profile email',
                  },
                  'server_metadata_url': 'https://auth-kvm.kubefrog.fr/realms/kubeflow/.well-known/openid-configuration'
              }
          }
        ]
        class OIDCSecurityManager(SupersetSecurityManager):
            auth_type = AUTH_OAUTH
            oauth_providers = AUTH_PROVIDERS

            def oauth_user_info(self, provider, response=None):
                if provider == 'keycloak':
                    idinfo = self.oauth_remotes[provider].parse_id_token(response)
                    logging.warning(f"OIDC user info: {idinfo}")
                    return {
                        'username': idinfo.get('preferred_username'),
                        'first_name': idinfo.get('given_name'),
                        'last_name': idinfo.get('family_name'),
                        'email': idinfo.get('email'),
                    }
        AUTH_TYPE = AUTH_OAUTH
        AUTH_USER_REGISTRATION = True
        AUTH_USER_REGISTRATION_ROLE = 'Gamma'
        CUSTOM_SECURITY_MANAGER = OIDCSecurityManager
        
    
    enable_CSV_upload: |

        CSV_TO_HIVE_UPLOAD_S3_BUCKET=env('CSV_TO_HIVE_UPLOAD_S3_BUCKET','')
        AWS_ACCESS_KEY_ID=env('AWS_ACCESS_KEY_ID','')
        AWS_SECRET_ACCESS_KEY=env('AWS_SECRET_ACCESS_KEY','')
        AWS_REGION=env('AWS_REGION','')
        S3_ENDPOINT=env('S3_ENDPOINT','')  
        S3_USE_HTTPS=env('S3_USE_HTTPS','')
        S3_VERIFY_SSL=env('S3_VERIFY_SSL','')

configMountPath: "/app/pythonpath"

extraConfigMountPath: "/app/configs"

image:
  repository: 192.168.0.10:5000/apache/superset
  tag: "5.0.0-prophet-clickhouse"
  pullPolicy: Always

imagePullSecrets: []

initImage:
  repository: apache/superset
  tag: 5.0.0-dockerize
  pullPolicy: IfNotPresent

service:
  type: ClusterIP
  port: 8088
  annotations: {}
    # cloud.google.com/load-balancer-type: "Internal"
  loadBalancerIP: null

resources: {}
  # We usually recommend not to specify default resources and to leave this as a conscious
  # choice for the user. This also increases chances charts run on environments with little
  # resources, such as Minikube. If you do want to specify resources, uncomment the following
  # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
  # limits:
  #   cpu: 100m
  #   memory: 128Mi
  # requests:
  #   cpu: 100m
  #   memory: 128Mi
hostAliases: []
# - hostnames:
#   - nodns.my.lan
#   ip: 18.27.36.45

##
## Superset node configuration
supersetNode:
  command:
    - "/bin/sh"
    - "-c"
    - ". {{ .Values.configMountPath }}/superset_bootstrap.sh; /usr/bin/run-server.sh"
  connections:
    redis_host: '{{ template "superset.fullname" . }}-redis-headless'
    redis_port: "6379"
    db_host: '{{ template "superset.fullname" . }}-postgresql'
    db_port: "5432"
    db_user: superset
    db_pass: superset
    db_name: superset
  env: {}
  forceReload: false # If true, forces deployment to reload on each upgrade
  initContainers:
    - name: wait-for-postgres
      image: busybox:latest
      imagePullPolicy: IfNotPresent
      envFrom:
        - secretRef:
            name: '{{ tpl .Values.envFromSecret . }}'
      command: [ "/bin/sh", "-c", "until nc -zv $DB_HOST $DB_PORT -w1; do echo 'waiting for db'; sleep 1; done" ]

  ## Annotations to be added to supersetNode deployment
  deploymentAnnotations: {}

  ## Annotations to be added to supersetNode pods
  podAnnotations: {}
  ## Labels to be added to supersetNode pods
  podLabels: {}
  livenessProbe:
    initialDelaySeconds: 15
    timeoutSeconds: 1
    failureThreshold: 3
    periodSeconds: 15
    successThreshold: 1
  readinessProbe:
    initialDelaySeconds: 15
    timeoutSeconds: 1
    failureThreshold: 3
    periodSeconds: 15
    successThreshold: 1
  # Resource settings for the supersetNode pods - these settings overwrite might existing values from the global resources object defined above.
  resources: {}
    # limits:
    #  cpu: 100m
    #  memory: 128Mi
    # requests:
    #  cpu: 100m
    #  memory: 128Mi
  podSecurityContext: {}
  containerSecurityContext: {}

##
## Superset worker configuration
supersetWorker:
  command:
    - "/bin/sh"
    - "-c"
    - ". {{ .Values.configMountPath }}/superset_bootstrap.sh; celery --app=superset.tasks.celery_app:app worker"
  forceReload: false # If true, forces deployment to reload on each upgrade
  initContainers:
    - name: wait-for-postgres
      image: busybox:latest
      imagePullPolicy: IfNotPresent
      envFrom:
        - secretRef:
            name: '{{ tpl .Values.envFromSecret . }}'
      command: [ "/bin/sh", "-c", "until nc -zv $DB_HOST $DB_PORT -w1; do echo 'waiting for db'; sleep 1; done" ]

  ## Annotations to be added to supersetWorker deployment
  deploymentAnnotations: {}

  ## Annotations to be added to supersetWorker pods
  podAnnotations: {}
  ## Labels to be added to supersetWorker pods
  podLabels: {}
  # Resource settings for the supersetWorker pods - these settings overwrite might existing values from the global resources object defined above.
  resources: {}
    # limits:
    #  cpu: 100m
    #  memory: 128Mi
    # requests:
    #  cpu: 100m
    #  memory: 128Mi
  podSecurityContext: {}
  containerSecurityContext: {}
##
## Superset beat configuration (to trigger scheduled jobs like reports)
supersetCeleryBeat:
  # This is only required if you intend to use alerts and reports
  enabled: false
  command:
    - "/bin/sh"
    - "-c"
    - ". {{ .Values.configMountPath }}/superset_bootstrap.sh; celery beat --app=superset.tasks.celery_app:app --pidfile /tmp/celerybeat.pid --schedule /tmp/celerybeat-schedule"
  forceReload: false # If true, forces deployment to reload on each upgrade
  initContainers:
    - name: wait-for-postgres
      image: busybox:latest
      imagePullPolicy: IfNotPresent
      envFrom:
        - secretRef:
            name: '{{ tpl .Values.envFromSecret . }}'
      command: [ "/bin/sh", "-c", "until nc -zv $DB_HOST $DB_PORT -w1; do echo 'waiting for db'; sleep 1; done" ]

  ## Annotations to be added to supersetCeleryBeat deployment
  deploymentAnnotations: {}

  ## Annotations to be added to supersetCeleryBeat pods
  pobAnnotations: {}
  ## Labels to be added to supersetCeleryBeat pods
  podLabels: {}
  # Resource settings for the CeleryBeat pods - these settings overwrite might existing values from the global resources object defined above.
  resources: {}
    # limits:
    #  cpu: 100m
    #  memory: 128Mi
    # requests:
    #  cpu: 100m
    #  memory: 128Mi
  podSecurityContext: {}
  containerSecurityContext: {}
##
## Init job configuration
init:
  # Configure resources
  # Warning: fab commant consumes a lot of ram and can
  # cause the process to be killed due to OOM if it exceeds limit
  resources: {}
    # limits:
    #   cpu:
    #   memory:
    # requests:
    #   cpu:
    #   memory:
  command:
    - "/bin/sh"
    - "-c"
    - ". {{ .Values.configMountPath }}/superset_bootstrap.sh; . {{ .Values.configMountPath }}/superset_init.sh"
  enabled: true
  loadExamples: false
  adminUser:
    username: admin
    firstname: Superset
    lastname: Admin
    email: admin@superset.com
    password: qeflhmlj54sd5s4s8
  initContainers:
    - name: wait-for-postgres
      image: busybox:latest
      imagePullPolicy: IfNotPresent
      envFrom:
        - secretRef:
            name: '{{ tpl .Values.envFromSecret . }}'
      command: [ "/bin/sh", "-c", "until nc -zv $DB_HOST $DB_PORT -w1; do echo 'waiting for db'; sleep 1; done" ]
  initscript: |-
    #!/bin/sh
    echo "Upgrading DB schema..."
    superset db upgrade
    echo "Initializing roles..."
    superset init
    echo "Creating admin user..."
    superset fab create-admin \
                    --username {{ .Values.init.adminUser.username }} \
                    --firstname {{ .Values.init.adminUser.firstname }} \
                    --lastname {{ .Values.init.adminUser.lastname }} \
                    --email {{ .Values.init.adminUser.email }} \
                    --password {{ .Values.init.adminUser.password }} \
                    || true
    {{ if .Values.init.loadExamples }}
    echo "Loading examples..."
    superset load_examples
    {{- end }}
  jobAnnotations:
    "argocd.argoproj.io/hook": Sync
    "argocd.argoproj.io/sync-wave": "0"
    "argocd.argoproj.io/hook-delete-policy": BeforeHookCreation,HookSucceeded
##
## Configuration values for the postgresql dependency.
## ref: https://github.com/kubernetes/charts/blob/master/stable/postgresql/README.md
postgresql:
  ##
  ## Use the PostgreSQL chart dependency.
  ## Set to false if bringing your own PostgreSQL.
  enabled: true
  fullnameOverride: superset-postgresql
  ## Authentication parameters
  auth:
    ## The name of an existing secret that contains the postgres password.
    existingSecret:
    ## PostgreSQL name for a custom user to create
    username: superset
    ## PostgreSQL password for the custom user to create. Ignored if `auth.existingSecret` with key `password` is provided
    password: superset
    ## PostgreSQL name for a custom database to create
    database: superset


  ## PostgreSQL Primary parameters
  primary:
    ##
    ## Persistent Volume Storage configuration.
    ## ref: https://kubernetes.io/docs/user-guide/persistent-volumes
    persistence:
      ##
      ## Enable PostgreSQL persistence using Persistent Volume Claims.
      enabled: true
      ##
      ## Persistant class
      # storageClass: classname
      ##
      ## Access modes:
      accessModes:
        - ReadWriteOnce
    ## PostgreSQL port
    service:
      ports:
        postgresql: "5432"

## Configuration values for the Redis dependency.
## ref: https://github.com/kubernetes/charts/blob/master/stable/redis/README.md
redis:
  ##
  ## Use the redis chart dependency.
  ##
  ## If you are bringing your own redis, you can set the host in supersetNode.connections.redis_host
  ##
  ## Set to false if bringing your own redis.
  enabled: true
  fullnameOverride: superset-redis
  ##
  ## Set architecture to standalone/replication
  architecture: standalone
  ##
  ## Auth configuration:
  ##
  auth:
    ## Enable password authentication
    enabled: false
    ## The name of an existing secret that contains the redis password.
    existingSecret: ""
    ## Name of the key containing the secret.
    existingSecretKey: ""
    ## Redis password
    password: superset
  ##
  ## Master configuration
  ##
  master:
    ##
    ## Image configuration
    # image:
      ##
      ## docker registry secret names (list)
      # pullSecrets: nil
    ##
    ## Configure persistance
    persistence:
      ##
      ## Use a PVC to persist data.
      enabled: true
      ##
      ## Persistant class
      # storageClass: classname
      ##
      ## Access mode:
      accessModes:
      - ReadWriteOnce


nodeSelector: {}

tolerations: []

affinity: {}
